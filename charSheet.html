<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Character Sheet - Liam Conroy</title>
	<link rel="stylesheet" href="css/style.css">
	<script type="text/javascript" src="js/paper-full.js"></script>
    <script src="http://www.parsecdn.com/js/parse-1.6.12.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/2.5.0/math.min.js"></script>
	<script type="text/paperscript" canvas="canvas">
    
    var allSkills = [];

    function Badge(pos, size, url, img) 
    {
        var active = false;
        
        this.path = new Path(
        {
            fillColor: 
            {
                hue: Math.random() * 360,
                saturation: 1,
                brightness: 1
            },
            //blendMode: 'screen'
        });

        this.path.strokeColor = 'black';
        this.path.fillColor = 'white';
        this.path.add(pos); 
        this.path.add(new Point(pos.x+size, pos.y)); 
        this.path.add(new Point(pos.x+size, pos.y-size));
        this.path.add(new Point(pos.x, pos.y-size));     
        this.path.closed = true;
        this.path.onMouseDown = function(event) 
        {
            console.log("click!");
            window.open(url, "_blank");
            this.active = true;
        }

        var image = new Raster(img);
        //image.scale(0.25);
        image.bounds = this.path.bounds;
        //image.fitBounds(path.bounds, true);
        var group = new Group([this.path, image]);
        //group.clipMask = true;
        group.clipped = true;

    }

    Badge.prototype = 
    {
        update: function()
        {
            if(this.active == true)
                this.scale(1.1, this.bounds.bottomLeft);
        }
    }

    function calculateTotalHours(skillObject)
    {
        var totalHours = 0;

        // this is clumsy, refactor to calculate on the parse side
        for(var i = 0; i < skillObject.skills.length; i++)
        {
            console.dir(_.indexOf(allSkillCategories, skillObject.skills.skillName));

            //allSkillCategories[_.indexOf(allSkillCategories, skillObject.skills.skillName)]
            totalHours += skillObject.skills[i].hours;
        }

        return totalHours;
    }

    function Skill(totalHours, badge) 
    {
        var active = false;
        
        //this.path = new Path.Circle(badge.path.position, totalHours/10);
        //this.fillColor = 'black';


        /*this.path = new Path.Circle(
        {
            fillColor: 
            {
                hue: Math.random() * 360,
                saturation: 1,
                brightness: 1
            },
            blendMode: 'screen'
        });*/

        //this.path.strokeColor = 'black';
        
        //this.path.onMouseDown = function(event) 
        //{
        //    console.log("clickCircle!");   
        //}

        //this.path.sendToBack();
    }

    Skill.prototype = 
    {
        update: function()
        {
            if(this.active == true)
                this.scale(1.1, this.bounds.bottomLeft);
        }
    }

    var allProjects = [];
    var allSkills = [];
    var allSkillTypes = [];
    var allSkillCategories = [];
    

    var badges = [];
    var skillCircles = [];


    // TODO: pull this in from backend
    var projectStatuses = ["Current", "Released", "Future", "On Hold", "Decommissioned", "Cancelled"];

    function drawProjectLabels()
    {
        var y = 50;
        var yStep = 70;

        for(var status in projectStatuses)
        {
            var currentProjectsText = new PointText(new Point(10, y));
            currentProjectsText.fillColor = 'black';
            currentProjectsText.content = projectStatuses[status] + ":";

            y+=yStep;
        }
    }

    function organiseSkillsByTime(allSkillsUniq)
    {

    }

    function drawProjectBoxes(projectData)
    {
        var initialX = 50;
        var y = 80;
        var yStep = 70;
        var xStep = 96;

        var requestsIn = 0;

        for(var i = 0; i < projectStatuses.length; i++)
        {
            var count = 0;

            _.each(projectData, function(project) 
            {
                if(project.get('Status') == projectStatuses[i])
                {
                    var projectName = new PointText(new Point(initialX+(xStep*count), y+(yStep*i)+20));
                    projectName.fillColor = 'black'
                    projectName.content = project.get('Name');

                    var badgePos = new Point(initialX+(xStep*count), y+(yStep*i));
                    badges.push(new Badge(badgePos, 128, project.get('URL'), project.get('imageName')));   

                    var skillsUsed = project.get("SkillsUsed");
                    var totalHours = 0;

                    for(var j = 0; j < skillsUsed.skills.length; j++)
                    {
                        var skill = skillsUsed.skills[j];
                        totalHours += skill.hours;
                    }

                    skillCircles.push(new Skill(totalHours,badges[badges.length - 1]));
                    count++;
                }
            });
        }
    }

    function onFrame(event)
    {
        for(var i = 0; i < badges.length; i++)
        {
            badges[i].update();
        }
        for(var i = 0; i < skillCircles.length; i++)
        {
            skillCircles[i].update();
        }
    }
    
    function initParse()
    {
        Parse.initialize("tpio94gHZkEKpbpxvjCAHKExanIx89VwpIsvtXt5", "aQsoxqb0x8tk09TprScWDnEiZs9SSQFN8qsE3bP1");
    }

    function drawSkillLabels(skillData)
    {
        var x = 198;
        var y = 10;
        var yStep = 11;

        for(var skill in skillData)
        {
            var skillText = new PointText(new Point(x, y));
            skillText.fillColor = 'black';
            skillText.justification = 'right';
            skillText.content = skillData[skill].skillName + ":";

            y+=yStep;
        }
    }

    function drawSkillCategories(categoryData)
    {
        var x = 10;
        var y = 10;
        var yStep = 11;

        for(var skillCategory in categoryData)
        {
            var skillCategoryText = new PointText(new Point(x, y));
            skillCategoryText.fillColor = 'black';
            skillCategoryText.content = categoryData[skillCategory].category;

            y+=yStep;
        }
    }
    function drawSkillBars(skillData)
    {
        var x = 200;
        var y = 10;
        var yStep = 11;
        var barHeight = 10;

        // draw horizontal bars for skills
        for(i = 0; i < skillData.length; i++)
        {
            var barHeightDampener = 2;

            var path = new Path();
            path.strokeColor = 'black';
            path.fillColor = 'black';
            path.add(new Point(x, y)); 
            path.add(new Point(x+(skillData[i].hours/barHeightDampener), y)); 
            path.add(new Point(x+(skillData[i].hours/barHeightDampener), y-barHeight)); 
            path.add(new Point(x, y-barHeight));     
            path.closed = true;

            y+=yStep;
        }
    }

    function getNumberOfMonths(from, to) 
    {
        var months;
        months = (to.getFullYear() - from.getFullYear()) * 12;
        months -= from.getMonth() + 1;
        months += to.getMonth();
        return months <= 0 ? 0 : months;
    }
    // port to moment.js?
    // times are occasionally coming out minus...

    function drawTimeLine(response)
    {
        // main line
        x = 10;
        xEnd = canvas.width-200;
        y = canvas.height-200;
        var path = new Path();
        path.strokeColor = 'black';
        path.fillColor = 'black';
        path.add(new Point(x, y)); 
        path.add(new Point(xEnd,y));

        drawProjectsOnTimeLine(xEnd-x, response);
    }

    function drawProjectsOnTimeLine(lineLength, response)
    {
        console.dir(response);

        var barHeight = 10;
        var currentY = canvas.height-200;
        var xStart = 10;

        // first just sort by start time and sort in y

        var allProjects = _.sortBy(response, 'StartDate');
 
        var firstDate = _.first(allProjects).get("StartDate");
        var lastDate  = new Date();

        var totalNumMonths = getNumberOfMonths(firstDate, lastDate);
        var oneMonthLength = lineLength/totalNumMonths;

        // year lines
        var monthCount = 0;

        // calculate properly from 1st
        var year = 2004;

        while(monthCount < totalNumMonths)
        {
            var path = new Path();
            path.strokeColor = 'black';
            path.fillColor = 'white';
            var xPos = xStart+(monthCount*oneMonthLength);
            // hack in time offset - calculate properly in the future!
            var yLen = ((monthCount+6) % 12) ? 2 : 5; 

            if(yLen == 5) // on a year border, label
            {
                var yearLabel = new PointText(new Point(xPos-14, currentY+24));
                yearLabel.fillColor = 'black';
                yearLabel.content = year;
                yearLabel.rotate(90);
                year++;
            }
            path.add(new Point(xPos, currentY)); 
            path.add(new Point(xPos, currentY+yLen));

            monthCount++;
        }

        _.each(allProjects, function(project) 
        {
            var lengthInMonths = getNumberOfMonths(project.get("StartDate"), project.get("EndDate"));
            var lengthInLine = lengthInMonths*oneMonthLength;
            var lengthInMonthsSinceBeginning = getNumberOfMonths(firstDate, project.get("StartDate"));
            var xOffset = xStart + lengthInMonthsSinceBeginning*oneMonthLength;
            
            var path = new Path();

            path.strokeColor = 'black';
            path.fillColor = 'white';
            path.add(new Point(xOffset, currentY)); 
            path.add(new Point(xOffset+lengthInLine,currentY));
            path.add(new Point(xOffset+lengthInLine,currentY-barHeight));
            path.add(new Point(xOffset,currentY-barHeight));
            path.closed = true;
            
            var projectsLabel = new PointText(new Point(xOffset+lengthInLine+2, currentY));
            projectsLabel.fillColor = 'black';
            projectsLabel.content = project.get("Name");

            var getProjectInfo = function(event) 
            {
                console.log("click!");
                window.open(project.get("URL"), "_blank");
                this.active = true;
            };

            path.onMouseDown = getProjectInfo;
            projectsLabel.onMouseDown = getProjectInfo;
            currentY -= barHeight;
        });
    }
    
    var categoryLabels = [];
    var crossoverPoint;
    var requestsIn = 0;


    function drawScreenFrame(x)
    {
        crossoverPoint = new Point(x,x*math.phi);;

        var horizontalBar = new Path();
        horizontalBar.strokeColor = 'red';
        horizontalBar.fillColor = 'red';
        horizontalBar.add(new Point(0, crossoverPoint.y)); 
        horizontalBar.add(new Point(canvas.width,crossoverPoint.y));

        var verticalBar = new Path();
        verticalBar.strokeColor = 'red';
        verticalBar.fillColor = 'red';
        verticalBar.add(new Point(crossoverPoint.x, 0)); 
        verticalBar.add(new Point(crossoverPoint.x, canvas.height-40));

        var categoriesDict = []; // create an empty array

        categoriesDict.push({
        key:   "Projects>>",
        value: 1
        });

        categoriesDict.push({
        key:   "Skills>>",
        value: 2
        });

        categoriesDict.push({
        key:   "Timeline>>",
        value: 3
        });

        var y = crossoverPoint.y;

        _.each(categoriesDict, function(category)
        {
            var categoryLabel = new PointText(new Point(crossoverPoint.x/2, y+16));
            categoryLabel.fillColor = 'black';
            categoryLabel.name = category.key;
            categoryLabel.justification = 'center';
            categoryLabel.content = category.key; 
            y += 16;

            var changeCategory = function() 
            {
                updateLayers(category.value);
                this.fillColor = 'red';
            };

            categoryLabel.onMouseDown = changeCategory;
            categoryLabels.push(categoryLabel);
        });
    }

    function pullParseData()
    {
        Parse.Cloud.run('getDataOfType', { "dataType": "categories" }).then(function(response) 
        {
            project.layers[1].activate();
            drawSkillCategories(response);
            project.layers[1].position.x += crossoverPoint.x;
            project.layers[1].visible  = false; 
        });

        Parse.Cloud.run('getDataOfType', { "dataType": "skills" }).then(function(response) 
        {
            project.layers[1].activate();
            drawSkillLabels(response);
            drawSkillBars(response);
            project.layers[1].position.x += crossoverPoint.x;
            project.layers[1].visible  = false; 
        }); 

        Parse.Cloud.run('getDataOfType', { "dataType": "project" }).then(function(response) 
        {
            project.layers[2].activate();
            drawProjectLabels();
            drawProjectBoxes(response);
            project.layers[2].position.x += crossoverPoint.x;
            project.layers[2].visible = false;

            project.layers[3].activate();
            drawTimeLine(response);
            project.layers[3].position.x += crossoverPoint.x;
            project.layers[3].visible = false;
        }); 

        /*
        Parse.Cloud.run('getDataOfType', { "dataType": "timeline" }).then(function(response) 
        {
            project.layers[3].activate();
            drawTimeLine();
        }); 
        */
    }
    function reduceSkillCategories()
    {
        var skills = Parse.Object.extend("Skills");
        var query = new Parse.Query(skills);

        query.find(
        {
            success: function(results) 
            {
                for (var j = 0; j < results.length; j++) 
                { 
                    var skillType = results[j];
                    allSkillTypes.push(skillType);
                }

                _.each(allSkillTypes, function(skillType) 
                {
                    var index = _.indexOf(allSkillCategories,skillType.get("Category"));

                    if(index == -1)
                    {
                        allSkillCategories.push(skillType.get("Category"));
                    }
                });

                if(requestsIn == 1)
                    createUI();
                else
                    requestsIn++;
            },

            error: function(error) 
            {
                alert("Error: " + error.code + " " + error.message);
            }
        });
    }
    function reduceSkills()
    {
        var allSkillsCopy = [];

        allSkills = _.reduce(allSkills, function(memo, skill) 
        {
            var index = _.indexOf(memo, skill.skillName);

            if(index === -1)
            {
                memo.push(skill.skillName);
                allSkillsCopy.push(skill);
                return memo;
            }
            else
            {
                allSkillsCopy[index].hours += skill.hours;
            }

            return memo;
        }, []);
    
        allSkills = _.sortBy(allSkillsCopy, 'hours').reverse();
    }
    function updateLayers(visibleIndex)
    {
        for(var i = 1; i < project.layers.length; i++)
        {
            project.layers[i].visible = i === visibleIndex ? true : false;
            categoryLabels[i-1].fillColor = i === visibleIndex ? 'red' : 'black';
        }
        //project.layers[visibleIndex].visible = true;
    }

    function drawAvatar()
    {
        var borderSize = 50;
        var path = new Path.Circle(new Point(crossoverPoint.x/2,crossoverPoint.x/2), crossoverPoint.x/2-(borderSize));
        path.fillColor = 'black';
        path.strokeColor = 'black';

        var image = new Raster('avatar.jpg');
        image.scale(0.3);
        image.bounds = path.bounds;
        //image.fitBounds(path.bounds, true);
        var group = new Group([path, image]);
        //group.clipMask = true;
        group.clipped = true;

        var nameText = new PointText(new Point(crossoverPoint.x/2, path.bounds.bottom+borderSize));
        nameText.fillColor = 'black';
        nameText.justification = 'center';
        nameText.content = 'Liam Conroy';

        var titleText = new PointText(new Point(crossoverPoint.x/2, nameText.bounds.bottom+borderSize));
        titleText.fillColor = 'black';
        titleText.justification = 'center';
        titleText.content = 'Freelance Game Engineer';

        var locationText = new PointText(new Point(crossoverPoint.x/2, titleText.bounds.bottom+borderSize));
        locationText.fillColor = 'black';
        locationText.justification = 'center';
        locationText.content = 'Kyoto, Japan';

    }

    function parseCloudCodeTests()
    {       
    }
    function drawContactsArea()
    {
        var contactsTextSpacing = 18;
        
        var contactInfo = ['Want to collaborate?\nHire me?\nFund a project?\nGet in touch!',
        'mail@liam-conroy.com','@LiamInJapan','@LiamInJapan','LinkedIn','+81 (0)80 4068 1273'].reverse();

        for(var i = 0; i < contactInfo.length; i++)
        {
            var yOffset = (i === contactInfo.length-1) ? ((contactsTextSpacing*(i+1))+60) : (contactsTextSpacing*(i+1));
            var mailText = new PointText(new Point(crossoverPoint.x/2, canvas.height-yOffset));
            mailText.fillColor = 'black';
            mailText.justification = 'center';
            mailText.content = contactInfo[i];
        }  
    }

    function drawStaticElements()
    {
        project.layers[0].activate();
        drawScreenFrame(250);
        drawAvatar();
        drawContactsArea();
    }

    function initialiseLayers()
    {
        var skillLayer = new Layer();
        skillLayer.activate();
        
        var projectLayer = new Layer();
        projectLayer.activate();
        
        var timeLayer = new Layer();
        timeLayer.activate();
    }
	function main()
	{
        initialiseLayers();
        drawStaticElements();

        initParse();
        pullParseData();
        //pullParseData();
	}

	main();

	function onResize(event) 
	{
	// Whenever the window is resized, recenter the path:
		//path.position = view.center;	
	}



	</script>
</head>
<body>
	<canvas id="canvas" resize stats hidpi="off"></canvas>
</body>
</html>